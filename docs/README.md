---
sidebar: auto
---

# 正则表达式

[[toc]]

## 创建RegExp对象

JavaScript的正则表达式是通过 **RegExp** 对象来表示的，而创建 **RegExp** 对象有两种方式：

### 1 直接量语法

```js
var pattern = /\d+/
```

### 2 RegExp构造函数

```js
var pattern = new RegExp("\\d+", 'g')
```

### 3 修饰符

- `i`: 匹配不区分大小写
- `g`: 执行全局匹配，会找到所有的匹配
- `m`: 多行匹配，其中 `^` 匹配行开头，`$` 匹配行结尾

通常都可以使用**直接量语法**来创建正则表达式，因为**直接量语法**写法相对简短一些。而通过 **RegExp()** 构造函数创建适合于需要动态创建正则表达式，正则表达式的主体部分是不确定的情况。

[获取url参数--RegExp构造函数创建动态正则表达式](#_2-获取url参数)

## 匹配字符

### 1 字符类

**字符类**表示的是匹配**字符类**中的字符之一，使用`[]`来定义字符类

使用正则的字符类去匹配字符串有时可以减少 `||` 运算符。

例如，判断一个数据的状态是否等于“1”，或等于“2”，或等于“3”的话，就可以使用字符类来实现，当然也可以定义数组来判断

```js
var status = '1'
console.log(/[123]/.test(status)) // true
```

#### 1.1 否定字符类

同时呢还有否定字符类，表示匹配的内容不能包含**字符类**的字符，否定字符类使用`[^]`来表示

使用否定字符类去匹配字符串有时可以减少 `&&` 运算符。

例如，判断一个数据的状态是否不等于“1”，且不等于“2”，且不等于“3”的话，就可以使用字符类来实现，当然也可以定义数组来判断

```js
var status = '1'
console.log(/[^123]/.test(status)) // false
```

#### 1.2 字符类范围

对于字符类的字符较多的情况下可以使用连字符 `-` 来简写，当然他们必须是连着的字符

比如 `[abcdef]` 可以改为 `[a-f]`

<!-- 若想匹配 `a` `-` `f` 这三个字符可通过转义 `-` 字符，或将 `-` 字符放于开头或结尾，写法可改为`[a/-f]`、`[-af]` 或 `[af-]` ，只要不被引擎认为是范围表示法即可 -->

#### 1.3 常用字符类

由于某些字符类非常常用，因此JavaScript的正则表达式语法使用一些特殊字符的转义字符来表示

- `\d` === `[0-9]`: 表示数字，是 **digit** 的简写
- `\D` === `[^0-9]`: 表示除数字外的任意字符
- `\w` === `[0-9a-zA-Z_]`: 表示数字、大小写字母及下划线，是 **word** 的简写
- `\W` === `[^0-9a-zA-Z_]`: 表示非单词字符
- `\s` === `[\t\v\n\r\f]`: 表示空白符（包括空格、水平制表符、垂直制表符、换行符、回车符或换页符），是 **space character** 的简写
- `\S` === `[^\t\v\n\r\f]`: 非空白符
- `.` === `[^\n\r\u2028\u2029]`: 表示除换行符、回车符、行分隔符和段分隔符外的任意字符

若想匹配任意字符，可使用 `[\d\D]`、`[\w\W]`、`[\s\S]`或`[^]` 来匹配

### 2 重复

#### 2.1 重复字符表示

- `{n,m}` 表示匹配字符最少n次，最多m次
- `{n}` 表示匹配字符n次
- `{n,}` 表示匹配字符n次或更多次

- `?` === `{0,1}` 表示匹配字符0次或1次
- `+` === `{1,}` 表示匹配字符1次或多次
- `*` === `{0,}` 表示匹配字符0次或多次

#### 2.2 非贪婪匹配

上面的匹配重复字符都是贪婪匹配，他们会尽可能多地匹配，比如 `/\d{2,3}/g` 就会尽可能的匹配3个字符

```js
var string = '123 3454 789'
console.log(string.match(/\d{2,3}/g))
// ["123", "345", "789"]
```

而非贪婪匹配则是在重复字符后面加上 `?` 实现的，比如 `{2,3}?`、`*?` 等等

```js
var string = '123 3454 789'
console.log(string.match(/\d{2,3}?/g))
// ["12", "34", "54", "78"]
```

<!-- ToDo: 还不晓得非贪婪匹配有啥用 -->

### 3 选择

使用字符 `|` 来分隔可选择的字符，也就是 “或” 的意思。例如 `/jpg|png|jpng/` 即可匹配 "jpg"，也可匹配"png"，还可匹配 "jpng" 字符串

::: tip
**注意** 选择项的尝试匹配次序是从左到右，也就是说如果左边的选择项匹配了，就会忽略右边的选择项，即使右边的选择项更匹配。例如当正则表达式 `/java|javaScript/` 去匹配字符串 "javaScript" 时，它只能匹配第一个字符，即 "java"
:::

```js
var string = 'javaScript'
console.log(string.match(/java|javaScript/g))
// ["java"]
```

若想尽可能的更好的匹配，可将更好的匹配字符放在左边

```js
var string = 'javaScript'
console.log(string.match(/javaScript|java"/g))
// ["javaScript"]
```

### 4 分组

分组是通过 `()` 来实现的，而在正则中括号有三个作用：**组合**、**引用分组**和**反向引用**

#### 4.1 组合

用括号将单独的项**组合**成子表达式，以便可以像处理一个独立的单元那样用 `|`、`*`、`?`、`+` 等来对单元内的项进行处理。

例如如果想匹配一至多个 "ab" 这样的组合项，需要使用 `/(ab)+/`

```js
console.log('ababab'.match(/ab+/g))
// ["ab", "ab", "ab"]
console.log('ababab'.match(/(ab)+/g))
// ["ababab"]
```

#### 4.2 引用分组

引用分组指的是我们可以引用 `()` 内的子表达式匹配到的文本，以此来实现正则表达式的检索与替换操作

##### 4.2.1 替换

引用分组经常用于替换操作中，当字符串的 `replace` 方法的第一个参数为正则表达式时，第二个参数可以通过 `$1`、`$2`、`...`、`$9` 来引用第一个参数的正则表达式的分组。

```js
var string = 'javascript'
console.log(string.replace(/(script)/, '-$1'))
// java-script
```

其中，`replace` 的第二个参数还可以是一个函数

具体实例可参考 [获取url-query对象](#_3-获取url-query对象)

##### 4.2.2 数据引用

string 的 `match` 和 regexp 的 `exec` 也可在匹配的结果中引用分组匹配的文本

例如，提取日期的年月日

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
console.log('2020'.match(regex))
// ["2020-03-30", "2020", "03", "30", index: 0, input: "2020-03-30", groups: undefined]
```

字符串的 `match` 方法返回一个数组，其中第一个元素是整体匹配结果，然后是各个引用分组匹配的结果。倘若正则表达式有修饰符 `g`，则返回的数组是各个引用分组匹配的结果。正则对象的 `exec` 方法与 字符串的 `match` 匹配的结果一样

#### 4.3 反向引用

**反向引用**指的是可以在同一正则表达式的后部引用前面的子表达式（也就是圆括号内的子表达式）匹配到的字符串，是通过在 `\` 后加一位或多位数字来实现的。其中数字对应圆括号的子表达式在正则表达式中的位置

例如 `\1` 表示正则表达式中从左到右第1个圆括号的子表达式匹配到的文本，以此类推，`\9` 表示第9个圆括号的子表达式匹配到的文本

以下例子用来测试日期格式是否正确，其中正则表达式的 \1 可以引用前面的括号匹配到的文本来保证日期的连接符是一致的

```js
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
console.log( regex.test("2020-03-30") ); // true
console.log( regex.test("2020/03/30") ); // true
console.log( regex.test("2020.03.30") ); // true
console.log( regex.test("2020-03/30") ); // false
```

<!-- #### 4.4 非捕获分组

上面例子中的分组都会捕获他们匹配到的文本以便后续引用，因此可称为捕获型分组

如果只是想用括号来将单独的项组合成子表达式，既不在API里引用，也不在在正则表达式里反向引用，则可以使用非捕获分组 `(?:p)` ，其中 `p` 是子表达式 -->

<!-- ToDo: 非捕获分组的eg -->

## 匹配位置

位置匹配是指匹配字符之间的位置，而不是实际的字符

![位置](./images/position.svg)

### 1 锚字符

在正则表达式中匹配位置的字符由于可以匹配字符串的特定位置，因此也被称为锚字符。

- `^` : 匹配开头，在多行匹配中匹配行开头
- `$` : 匹配结尾，在多行匹配中匹配行结尾
- `\b` : 匹配单词的边界，具体就是 `\w` 和 `\W` 、`\w` 和 `^` 以及 `\w` 和 `$` 之间的位置
- `\B` : 匹配非单词边界，也就是除了 `\b` 匹配的位置外的所有位置
- `(?:p)` : 正向先行断言，要求接下来的字符要与 `p` 匹配，可以理解为模式 `p` 前面的位置
- `(?!p)` : 反向先行断言，要求接下来的字符不与 `p` 匹配

<!-- 例如，字符串 “hello world” 的锚字符对应的位置如下: -->

<!-- ![锚字符](./images/anchor.svg) -->

所有匹配的位置都是可以被替换的

```js
var string = 'hello world'
console.log(string.replace(/^|$/g, '#'))
// #hello world#
console.log(string.replace(/\b/g, '#'))
// #hello# #world#
console.log(string.replace(/\B/g, '#'))
// h#e#l#l#o w#o#r#l#d
console.log(string.replace(/(?=llo)/g, '#'))
// he#llo world
console.log(string.replace(/(?!=llo)/g, '#'))
// #h#el#l#o# #w#o#r#l#d#
```

## 实际案例

### 1 数字的千分位分隔符

```js
var result = '1234567.12'.replace(/(?=(\d{3})+\b)/g, ',')
console.log(result)
// 1,234,567.12
```

- `(\d{3})` 表示匹配3个数字。例如 `123`，`456`
- `(\d{3}+)` 表示匹配的数字个数是3的整数倍。例如 `123456`，`456`
- `(\d{3}+\b)` 表示匹配的数字个数是3的整数倍且后面是单词边界（若有小数点，小数点后面的数字不匹配）。例如 `234567.`，`567.`
- `(?=(\d{3}+\b))` 表示匹配的数字个数是3的整数倍且后面单词边界前面的位置。例如 `234567.` 前面的位置，`567.`前面的位置

最后只要将匹配的位置替换为 `,` 即可

但是如果整数的个数是3的倍数时就会有点问题

```js
var result = '123456789.12'.replace(/(?=(\d{3})+\b)/g, ',')
console.log(result)
// ,123,456,789.12
```

说明匹配到的位置不能是开头，所以使用 `(?!^)` 来限制

```js
var result = '123456789.12'.replace(/(?!^)(?=(\d{3})+\b)/g, ',')
console.log(result)
// 123,456,789.12
```

也可以用 `\B` 来代替 `(?!^)` ，因为 `\B` 也可以匹配非开头位置

所以最终的正则表达式可改为:

```js
var result = '123456789.12'.replace(/\B(?=(\d{3})+\b)/g, ',')
console.log(result)
// 123,456,789.12
```

可以看看可视图的正则

![千分位正则可视图](./images/thousands.png)

### 2 获取url参数

使用 `RegExp()` 构造函数构建动态正则表达式

```js
function getQueryParam(key) {
  var reg = new RegExp('(^|&)' + key + '=([^&]*)(&|$)', 'i')
  var result = window.location.search.substr(1).match(reg)  
  if (result != null) {
    return decodeURIComponent(result[2])
  }
  return null
}

getQueryParam('userid')
```

- `(^|&)` 匹配参数字符串的开头或 `&` 字符
- `([^&]*)` 匹配非 `&` 的多个任意字符，此处匹配的是 `key` 对应的值，它会出现在匹配结果的第三项
- `(&|$)` 匹配 `&` 字符或结尾

### 3 获取url query对象

若想获取所有的URL参数对象可使用以下方法

```js
function getQuery() {
  var reg = /(^|&)([^=]*)=([^&]*)/ig
  var string = window.location.search.substr(1)
  var result = {}
  string.replace(reg, (match, p1, key, value, p4) => {
    result[key] = decodeURIComponent(value)
  })
  return result
}

getQuery()
```

## 附录

- [正则可视化工具](https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24)
- [正则在线测试工具(regex101)](https://regex101.com/)
